# Vue 2.0 调整依赖收集粒度，引入虚拟DOM

为了在大型项目上有更好的性能表现，Vue2.0版本做出了很大的调整。从下面的 **流程图** 中，我们不难发现 Vue 的架构体系有了直观的变化

- 相比 **1.0** 版本，出现了 **组件** 的概念
- 将依赖收集的**粒度**调整为「组件级别」，即一个组件就是一个 **Watcher**
- 引入了 **虚拟DOM** 并且成为了渲染流程中非常重要的一环

![](https://files.mdnice.com/user/56690/9443187a-f211-4735-99d8-12f3d2fd3d3b.png)

整体上来看，**「响应式」**数据不再关注组件内部的「依赖」，当数据被修改后只通知到**组件**，组件再通过 **diff** 算法找出「虚拟DOM」中变化部分，将这部分更新到「真实DOM」上。这本质上是 **时间换空间** 的权衡，通过适当降低 **「运行时」** 的 **「更新效率」** 来换取更少的 **「内存开销」**

同时期 Vue 也新增了 **SFC（.vue文件）**，由于 **.vue** 文件是框架提供的```“魔法”```，并不能直接交给浏览器去执行，因此就需要一个能打破```“魔法”```的工具，将 **.vue** 转换为 **.js**，这个工具的核心就是 **编译器（compiler）**，打破魔法的过程则被称为 **编译（compile）**，也就是说经过编译后，我们在 **.vue** 文件中写的 ```v-if, v-for, 插值表达式``` 等等特性都会变成普通的 **javascript** 逻辑。**template** 也就是在这个阶段被转换为了 **render** 函数

![](https://files.mdnice.com/user/56690/b58cb367-3d16-4e49-ad08-d9e9edf52ae2.png)

虽然 1.0 版本中也存在 **compile** 过程，但做的事儿却发生了很大的变化

| compile       | 1.0   |  2.0 |
| :-         | :--: |   :-:  |
| 阶段     |  运行时  |     编译时 |
| 作用     |  将模板中的 **指令，插值** 等解析为对应的逻辑并执行  |  将模板解析为抽象语法树(**AST**)，生成渲染函数 |

通过简单的对比我们不难发现，尽管编译的执行阶段完全不同了，对**模板的解析**还是主旋律

其实到这里，是不是感觉 Vue 已经从架构上做到了极致的优化？不要着急，我们看完 Vue 3.0 版本的演进后再下论断
