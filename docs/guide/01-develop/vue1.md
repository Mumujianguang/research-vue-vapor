# Vue 1.0 量子纠缠式的细粒度绑定
这是 Vue 初具雏形的一个里程碑，此时还没有完备的 **响应式** 系统，这个时期大家谈论得最多的是基于 **数据劫持 + 依赖收集** 的响应式实现方案，以及实现细节中的 **Watcher** 与 **Dep** 两兄弟

没有了解过的同学可以看一下这张「渲染流程图」，能帮助你快速建立起对 Vue1.0 版本的认知

![](https://files.mdnice.com/user/56690/b2373779-d4d1-48c2-9a48-1d5ede62a04a.png)


在还没有 **SFC**（单文件组件）之前，Vue 可以说是一个实打实的 **「运行时」** 框架，上图简要体现了当我们 **new Vue({...})** 之后，发生的一系列过程

- 用 **defineProperty** 实现数据劫持，目的是代理数据，拦截所有对数据的 **get** 和 **set** 操作，这个过程也被称为「getter/setter」化

- 属性的「getter」的主要作用是 **收集依赖**。这里的「依赖」是指所有访问该属性的 **逻辑**，可能是一个「计算属性」，可能是一个「监听器」，也可能是模版中的「指令」或者「插值表达式」。在实现层面，这些不同的依赖都被抽象为了一个统一的概念 —— **Watcher**，会被存储在每个属性的 **Dep** 实例中 

- 属性的「setter」则是当数据被修改后，通知 **Dep** 中收集的 **Watcher** 去更新视图

在整个流程中，Vue 依赖收集的 **「粒度」** 是很细的，只要是访问了 **「响应式」** 数据的地方，都会被作为 **「依赖」** 给收集起来

往上层说，也就是 **「数据」** 与对应的 **「UI」** 形成了绑定关系，这也是让 Vue 在「更新视图」时有着极高的**效率**的根本原因。这种绑定关系就像量子纠缠一样，**「数据」**变化的同时 **「UI」** 就能收到通知从而做出更新

但任何事物都有两面性，过细的依赖收集是优势也是短板，随着项目体量的增长，运行时会产生越来越多的 **Watcher** 和 **Dep**，导致占用过多的内存，进而影响页面的性能。

如果一个方案只能支撑小体量的项目有良好的 **「性能」** 表现，显然不是「最优解」